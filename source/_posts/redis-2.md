---
layout: post
title: redis进阶之复制
date: 2020-11-28 16:00:00
tags: 
- redis
categories:
- redis
---

### 建立复制

参与复制的Redis实例划分为主节点(master)和从节点(slave)。默认情况下，Redis都是主节点。每个从节点只能有一个主节点，而主节点可以 同时具有多个从节点。复制的数据流是单向的，只能由主节点复制到从节 点。配置复制的方式有以下三种:

- 1) 在配置文件中加入slaveof{masterHost}{masterPort}随Redis启动生效。
- 2) 在redis-server启动命令后加入--slaveof{masterHost}{masterPort}生 效。
- 3) 直接使用命令:slaveof{masterHost}{masterPort}生效。

综上所述，slaveof命令在使用时，可以运行期动态配置，也可以提前写 到配置文件中。slaveof本身是异步命令，执行slaveof命令时，节点只保存主节点信息后 返回，后续复制流程在节点内部异步执行.

### 断开复制

slaveof命令不但可以建立复制，还可以在从节点执行slaveof no one来断 开与主节点复制关系。

断开复制主要流程:

- 1) 断开与主节点复制关系。
- 2) 从节点晋升为主节点。
  
从节点断开复制后并不会抛弃原有数据，只是无法再获取主节点上的数据变化。

通过slaveof命令还可以实现切主操作，所谓切主是指把当前从节点对主 节点的复制切换到另一个主节点。执行slaveof{newMasterIp} {newMasterPort}命令即可.
切主操作流程如下:

- 1) 断开与旧主节点复制关系。 
- 2) 与新主节点建立复制关系。 
- 3) 删除从节点当前所有数据。 
- 4) 对新主节点进行复制操作。

slave默认只读。

### 拓扑

Redis的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种:一主一从、一主多从、树状主从结构

#### 一主一从结构

一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点 提供故障转移支持。当应用写命令并发量较高且需要持久化时，可以只在从节点上开启AOF，这样既保证数据安全性同时也避免了持久化对主节点的性能干扰。

但需要注意的是，当主节点关闭持久化功能时， 如果主节点脱机要避免自动重启操作。因为主节点之前没有开启持久化功能自动重启后数据集为空，这时从节点如果继续复制主节点会导致从节点数据也被清空的情况，丧失了持久化的意义。安全的做法是在从节点上执行slaveof no one断开与主节点的复制关系，再重启主节点从而避免这一问题。

![image.png](https://i.loli.net/2020/11/29/ypJUwENo5thcYHr.png)

#### 一主多从结构

一主多从结构(又称为星形拓扑结构)使得应用端可以利用多个从节点实现读写分离。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。同时在日常开发中如果需要执行一些比较耗时的读命令，如:keys、sort等，可以在其中一台从节点上执行，防止慢查询对主节点造成阻塞从而影响线上服务的稳定性。对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。

![image.png](https://i.loli.net/2020/11/29/bEGQAhvFk9s5L2o.png)

#### 树状主从结构

树状主从结构(又称为树状拓扑结构)使得从节点不但可以复制主节点 数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中 间层，可以有效降低主节点负载和需要传送给从节点的数据量。

如图6-6所示，数据写入节点A后会同步到B和C节点，B节点再把数据同步到D和E节点，数据实现了一层一层的向下复制。当主节点需要挂载多个从节点时为了避免对主节点的性能干扰，可以采用树状主从结构降低主节点压力。

![image.png](https://i.loli.net/2020/11/29/lxH2JZrfC5VMdeP.png)

### 原理

#### 复制过程

在从节点执行slaveof命令后，复制过程便开始运作，下面详细介绍建立 复制的完整流程

![image.png](https://i.loli.net/2020/11/29/gR7ezl3LyfnNIST.png)

从图中可以看出复制过程大致分为6个过程:

- 1) 保存主节点(master)信息。执行slaveof后从节点只保存主节点的地址信息便直接返回，这时建立复 制流程还没有开始
- 2) 从节点(slave)内部通过每秒运行的定时任务维护复制相关逻辑， 当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接，如果从节点无法建立连接，定时任务会无限重试直到连接成功或者执行 slaveof no one取消复制
- 3) 发送ping命令。连接建立成功后从节点发送ping请求进行首次通信，ping请求主要目的如下: 
   ·检测主从之间网络套接字是否可用。·检测主节点当前是否可接受处理命令。
   如果发送ping命令后，从节点没有收到主节点的pong回复或者超时，比如网络超时或者主节点正在阻塞无法响应命令，从节点会断开复制连接，下次定时任务会发起重连
- 4) 权限验证。如果主节点设置了requirepass参数，则需要密码验证， 从节点必须配置masterauth参数保证与主节点相同的密码才能通过验证;如 果验证失败复制将终止，从节点重新发起复制流程。
- 5) 同步数据集。主从复制连接正常通信后，对于首次建立复制的场 景，主节点会把持有的数据全部发送给从节点，这部分操作是耗时最长的步 骤。Redis在2.8版本以后采用新复制命令psync进行数据同步，原来的sync命 令依然支持，保证新旧版本的兼容性。新版同步划分两种情况:全量同步和 部分同步，下一节将重点介绍。
- 6) 命令持续复制。当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。

#### 数据同步

- 全量复制: 一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。
- 部分复制: 用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。

部分复制是对老版复制的重大优化，有效避免了不必要的全量复制操作。因此当使用复制功能时，尽量采用2.8以上版本的Redis。

psync命令运行需要以下组件支持: 

- 主从节点各自复制偏移量
  参与复制的主从节点都会维护自身复制偏移量。主节点(master)在处理完写入命令后，会把命令的字节长度做累加记录，从节点(slave)每秒钟上报自身的复制偏移量给主节点，因此主节点 也会保存从节点的复制偏移量，从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。
  ![image.png](https://i.loli.net/2020/11/29/OQwCGi5rc4u1PI6.png)
- 主节点复制积压缓冲区
  复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为 1MB，当主节点有连接的从节点(slave)时被创建，这时主节点(master) 响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区，由于缓冲区本质上是先进先出的定长队列，所以能实现保存最近已复制数据的功能，用于部分复制和复制命令丢失的数据补救。
  ![image.png](https://i.loli.net/2020/11/29/1m9UBd4rZEzTIMf.png)
- 主节点运行id
  每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运 行ID。运行ID的主要作用是用来唯一识别Redis节点，比如从节点保存主节 点的运行ID识别自己正在复制的是哪个主节点。如果只使用ip+port的方式识 别主节点，那么主节点重启变更了整体数据集(如替换RDB/AOF文件)， 从节点再基于偏移量复制数据将是不安全的，因此当运行ID变化后从节点将 做全量复制。需要注意的是Redis关闭再启动后，运行ID会随之改变。

psync命令

从节点使用psync命令完成部分复制和全量复制功能，命令格式:
`psync{runId}{offset}`，参数含义如下:

- runId:从节点所复制主节点的运行id。
- offset:当前从节点已复制的数据偏移量。

![image.png](https://i.loli.net/2020/11/29/RqnVWODgUShFpv8.png)

流程说明:

- 1) 从节点(slave)发送psync命令给主节点，参数runId是当前从节点保存的主节点运行ID，参数offset是当前从节点保存的复制偏移量，如果是第一次参与复制则默认值为-1。
- 2) 主节点(master)根据psync参数和自身数据情况决定响应结果: 
  - 如果回复+FULLRESYNC{runId}{offset}，那么从节点将触发全量复制
  - 如果回复+CONTINUE，从节点将触发部分复制
  - 如果回复+ERR，说明主节点版本低于Redis2.8，无法识别psync命令， 从节点将发送旧版的sync命令触发全量复制流程

##### 全量复制

全量复制是Redis最早支持的复制方式，也是主从第一次建立复制时必须经历的阶段。

这里主要介绍psync全量复制流程，它与2.8以前的sync全量复制机制基本一致。全量复制的完整运行流程如图6-15所示。

![image.png](https://i.loli.net/2020/11/29/jaF3BJUM6h2TLwG.png)

- 1) 发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。
- 2) 主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。
- 3) 从节点接收主节点的响应数据保存运行ID和偏移量offset
- 4) 主节点执行bgsave保存RDB文件到本地
- 5) 主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件，接收完RDB后从节点打印相关日志。需要注意，对于数据量较大的主节点，比如生成的RDB文件超过6GB以上时要格外小心。传输文件这一步操作非常耗时，速度取决于主从节点之间网络带宽，如果总时间超过 repl-timeout所配置的值(默认60秒)，从节点将放弃接受RDB文件并清理已 经下载的临时文件，导致全量复制失败。
- 6) 对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读 写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当 从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证 主从之间数据一致性。如果主节点创建和传输RDB的时间过长，对于高流量 写入场景非常容易造成主节点复制客户端缓冲区溢出。
- 7) 从节点接收完主节点传送来的全部数据后会清空自身旧数据
- 8) 从节点清空数据后开始加载RDB文件，对于较大的RDB文件，这一步操作依然比较耗时。对于线上做读写分离的场景，从节点也负责响应读命令。如果此时从节 点正出于全量复制阶段或者复制中断，那么从节点在响应读命令可能拿到过 期或错误的数据。对于这种场景，Redis复制提供了slave-serve-stale-data参 数，默认开启状态。如果开启则从节点依然响应所有命令。对于无法容忍不 一致的应用场景可以设置no来关闭命令执行，此时从节点除了info和slaveof 命令之外所有的命令只返回“SYNC with master in progress”信息。
- 9) 从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。

##### 部分复制

部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。

当从节点(slave)正在复制主节点 (master)时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据，所以开销很小。

![image.png](https://i.loli.net/2020/11/29/ZvknEHzgOia2cdb.png)

流程说明:

- 1) 当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接
- 2) 主从连接中断期间主节点依然响应命令，但因复制连接中断命令无 法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最 近一段时间的写命令数据，默认最大缓存1MB。
- 3) 当主从节点网络恢复后，从节点会再次连上主节点
- 4) 当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和 主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部 分复制操作。
- 5) 主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点;之后根据参数offset在自身复制积压缓 冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。
- 6)主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证 主从复制进入正常状态。发送的数据量可以在主节点的日志获取。

##### 心跳

主从节点在建立复制后，它们之间维护着长连接并彼此发送心跳命令

主节点默认每隔10秒对从节点发送ping命令，判断从节点的存活性 和连接状态。可通过参数repl-ping-slave-period控制发送频率。

从节点在主线程中每隔1秒发送replconf ack{offset}命令，给主节点 上报自身当前的复制偏移量。

##### 异步复制

主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成。由于主从复制过程是异步的，就会造成从节点的数据相对主节点存在延迟。

### 复制中遇到的问题

#### 读写分离

对于读占比较高的场景，可以通过把一部分读流量分摊到从节点 (slave)来减轻主节点(master)压力，同时需要注意永远只对主节点执行写操作。

当使用从节点响应读请求时，业务端可能会遇到如下问题:

- 复制数据延迟。 
  Redis复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络带宽和命令阻塞情况，比如刚在主节点写入数据后立刻在从节点上读取可 能获取不到。需要业务场景允许短时间内的数据延迟。对于无法容忍大量延 迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点
- 读到过期数据。
  当主节点存储大量设置超时的数据时，如缓存数据，Redis内部需要维 护过期数据删除策略，删除策略主要有两种:惰性删除和定时删除。
  - 惰性删除:主节点每次处理读取命令时，都会检查键是否超时，如果超 时则执行del命令删除键对象，之后del命令也会异步发送给从节点。需要注 意的是为了保证复制的一致性，从节点自身永远不会主动删除超时数据
  ![image.png](https://i.loli.net/2020/11/29/5C9hJkKIfb2ByFD.png)
  - 定时删除:Redis主节点在内部定时任务会循环采样一定数量的键，当发现采样的键过期时执行del命令，之后再同步给从节点，如果此时数据大量超时，主节点采样速度跟不上过期速度，且主节点没有读取过期键的操作，那么从节点将无法收到del命令。这时在从节点上可以读取到已经超时的数据。Redis在3.2版本解决了这个问题，从节点读取数据之前，会检查键的过期时间来决定是否返回数据。
  ![image.png](https://i.loli.net/2020/11/29/GJ6H8bn1D7ouF5Z.png)
- 从节点故障
  对于从节点的故障问题，需要在客户端维护可用从节点列表，当从节点 故障时立刻切换到其他从节点或主节点上。这个过程类似上文提到的针对延 迟过高的监控处理，需要开发人员改造客户端类库。

**综上所出，使用Redis做读写分离存在一定的成本。Redis本身的性能非常高，开发人员在使用额外的从节点提升读性能之前，尽量在主节点上做充分优化，比如解决慢查询，持久化阻塞，合理应用数据结构等，当主节点优 化空间不大时再考虑扩展。笔者建议大家在做读写分离之前，可以考虑使用 Redis Cluster等分布式解决方案，这样不止扩展了读性能还可以扩展写性能和可支撑数据规模，并且一致性和故障转移也可以得到保证，对于客户端的维护逻辑也相对容易。**

#### 主从配置不一致

主从配置不一致是一个容易忽视的问题。对于有些配置主从之间是可以 不一致，比如:主节点关闭AOF在从节点开启。但对于内存相关的配置必须 要一致，比如maxmemory，hash-max-ziplist-entries等参数。当配置的 maxmemory从节点小于主节点，如果复制的数据量超过从节点maxmemory 时，它会根据maxmemory-policy策略进行内存溢出控制，此时从节点数据已 经丢失，但主从复制流程依然正常进行，复制偏移量也正常。修复这类问题 也只能手动进行全量复制。当压缩列表相关参数不一致时，虽然主从节点存 储的数据一致但实际内存占用情况差异会比较大

#### 规避全量复制

- 第一次建立复制: 不可避免
- 节点运行ID不匹配: 提供故障转移功能。当主节点 发生故障后，手动提升从节点为主节点或者采用支持自动故障转移的哨兵或集群方案。
- 复制积压缓冲区不足: 当主从节点网络中断后，从节点再次连上主节 点时会发送psync{offset}{runId}命令请求部分复制，如果请求的偏移量不在 主节点的积压缓冲区内，则无法提供给从节点数据，因此部分复制会退化为 全量复制。针对这种情况需要根据网络中断时长，写命令数据量分析出合理 的积压缓冲区大小。

#### 规避复制风暴

复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点 短时间内发起全量复制的过程。复制风暴对发起复制的主节点或者机器造成 大量开销，导致CPU、内存、带宽消耗。因此我们应该分析出复制风暴发生 的场景，提前采用合理的方式规避。规避方式有如下几个。

- 单主节点复制风暴
  单主节点复制风暴一般发生在主节点挂载多个从节点的场景。当主节点 重启恢复后，从节点会发起全量复制流程，这时主节点就会为从节点创建 RDB快照，如果在快照创建完毕之前，有多个从节点都尝试与主节点进行全 量同步，那么其他从节点将共享这份RDB快照。这点Redis做了优化，有效避免了创建多个快照。但是，同时向多个从节点发送RDB快照，可能使主节 点的网络带宽消耗严重，造成主节点的延迟变大，极端情况会发生主从节点 连接断开，导致复制失败。
  解决方案首先可以减少主节点(master)挂载从节点(slave)的数量， 或者采用树状复制结构，加入中间层从节点用来保护主节点。
  从节点采用树状树非常有用，网络开销交给位于中间层的从节点，而不 必消耗顶层的主节点。但是这种树状结构也带来了运维的复杂性，增加了手 动和自动处理故障转移的难度。

- 单机器复制风暴
  由于Redis的单线程架构，通常单台机器会部署多个Redis实例。当一台机器(machine)上同时部署多个主节点(master)时，如果这台机器出现故障或网络长时间中断，当它重启恢复后，会有大量 从节点(slave)针对这台机器的主节点进行全量复制，会造成当前机器网络带宽耗尽。避免方法如下:
  - 应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。
  - 当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。
